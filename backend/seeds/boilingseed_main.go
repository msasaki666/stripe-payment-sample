// Code generated by SQLBoiler boilingseed-0.1.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package seeds

import (
	"context"
	"fmt"
	"math/rand"
	"sync"
	"time"

	models "github.com/msasaki666/backend/models"
	"github.com/volatiletech/sqlboiler/v4/boil"
)

type Seeder struct {
	// The minimum number of Customers to seed
	MinCustomersToSeed int
	// RandomCustomer creates a random models.Customer
	// It does not need to add relationships.
	// If one is not set, defaultRandomCustomer() is used
	RandomCustomer func() (*models.Customer, error)
	// AfterCustomersAdded runs after all Customers are added
	AfterCustomersAdded func(ctx context.Context) error

	// The minimum number of SchemaMigrations to seed
	MinSchemaMigrationsToSeed int
	// RandomSchemaMigration creates a random models.SchemaMigration
	// It does not need to add relationships.
	// If one is not set, defaultRandomSchemaMigration() is used
	RandomSchemaMigration func() (*models.SchemaMigration, error)
	// AfterSchemaMigrationsAdded runs after all SchemaMigrations are added
	AfterSchemaMigrationsAdded func(ctx context.Context) error

	// The minimum number of StripePrices to seed
	MinStripePricesToSeed int
	// RandomStripePrice creates a random models.StripePrice
	// It does not need to add relationships.
	// If one is not set, defaultRandomStripePrice() is used
	RandomStripePrice func() (*models.StripePrice, error)
	// AfterStripePricesAdded runs after all StripePrices are added
	AfterStripePricesAdded func(ctx context.Context) error

	// The minimum number of StripeProducts to seed
	MinStripeProductsToSeed int
	// RandomStripeProduct creates a random models.StripeProduct
	// It does not need to add relationships.
	// If one is not set, defaultRandomStripeProduct() is used
	RandomStripeProduct func() (*models.StripeProduct, error)
	// AfterStripeProductsAdded runs after all StripeProducts are added
	AfterStripeProductsAdded func(ctx context.Context) error

	// The minimum number of StripeRecurrings to seed
	MinStripeRecurringsToSeed int
	// RandomStripeRecurring creates a random models.StripeRecurring
	// It does not need to add relationships.
	// If one is not set, defaultRandomStripeRecurring() is used
	RandomStripeRecurring func() (*models.StripeRecurring, error)
	// AfterStripeRecurringsAdded runs after all StripeRecurrings are added
	AfterStripeRecurringsAdded func(ctx context.Context) error

	// Number of times to retry getting a unique relationship in many-to-many relationships
	Retries int
}

func (s Seeder) Run(ctx context.Context, exec boil.ContextExecutor) error {
	rand.Seed(time.Now().Unix())
	var wg sync.WaitGroup

	ctxMain, cancelMain := context.WithCancel(ctx)
	defer cancelMain()

	ctxCustomers, cancelCustomers := context.WithCancel(ctxMain)
	ctxSchemaMigrations, cancelSchemaMigrations := context.WithCancel(ctxMain)
	ctxStripePrices, cancelStripePrices := context.WithCancel(ctxMain)
	ctxStripeProducts, cancelStripeProducts := context.WithCancel(ctxMain)
	ctxStripeRecurrings, cancelStripeRecurrings := context.WithCancel(ctxMain)

	errChan := make(chan error, 5)

	// RunCustomersSeed()
	wg.Add(1)
	go func() {
		defer cancelCustomers()
		defer wg.Done()

		if err := s.seedCustomers(ctxCustomers, exec); err != nil {
			errChan <- err
			cancelMain()
		}
	}()

	// RunSchemaMigrationsSeed()
	wg.Add(1)
	go func() {
		defer cancelSchemaMigrations()
		defer wg.Done()

		if err := s.seedSchemaMigrations(ctxSchemaMigrations, exec); err != nil {
			errChan <- err
			cancelMain()
		}
	}()

	// RunStripePricesSeed()
	wg.Add(1)
	go func() {
		defer cancelStripePrices()
		defer wg.Done()

		if err := s.seedStripePrices(ctxStripePrices, exec); err != nil {
			errChan <- err
			cancelMain()
		}
	}()

	// RunStripeProductsSeed()
	wg.Add(1)
	go func() {
		defer cancelStripeProducts()
		defer wg.Done()

		if err := s.seedStripeProducts(ctxStripeProducts, exec); err != nil {
			errChan <- err
			cancelMain()
		}
	}()

	// RunStripeRecurringsSeed()
	wg.Add(1)
	go func() {
		defer cancelStripeRecurrings()
		defer wg.Done()

		if err := s.seedStripeRecurrings(ctxStripeRecurrings, exec); err != nil {
			errChan <- err
			cancelMain()
		}
	}()

	wg.Wait()

	close(errChan)
	err := <-errChan
	if err != nil {
		return err
	}

	return nil
}

// These packages are needed in SOME models
// This is to prevent errors in those that do not need it
var _ fmt.Scanner
var _ = models.NewQuery()
